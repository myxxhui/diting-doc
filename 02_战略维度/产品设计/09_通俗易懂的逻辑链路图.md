# L2 · 通俗易懂的逻辑链路图

> [!NOTE] **[TRACEBACK] 战略维度锚点**
> - **顶层概念**: [一句话定义与核心价值](../../01_顶层概念/01_一句话定义与核心价值.md)
> - **本文档**: L2 层级，用通俗易懂的图表解释各战略维度的逻辑

**一致性约定**：本图与 02～08、开发与交付维度及 [03_原子目标与规约](../../03_原子目标与规约/) 一致；若与 L3 规约冲突，**以 L3 为准**。当 L2 或 L3 发生重大变更时，须同步更新本图（责任：当次变更执行方或文档负责人）。

## 零、双轨制总览：A 轨与 B 轨如何分流

谛听采用**双轨制（Barbell）**：**A 轨（现金奶牛，约 80% 资金）**走不可能三角与 2% 止损/现金拖累；**B 轨（长期捕手，约 20% 资金）**由 VC-Agent/信仰专家驱动，经判官 **TimeHorizon = LONG_TERM** 分流后豁免 2% 与现金拖累，仅施加逻辑证伪与大周期反转。详见 [01_一句话定义与核心价值](../../01_顶层概念/01_一句话定义与核心价值.md)、[03_双轨制与VC-Agent](../../01_顶层概念/03_双轨制与VC-Agent.md)。

```mermaid
flowchart TB
    subgraph 入口[共用入口]
        DATA[数据采集]
        SCAN[量化扫描 + 策略池]
        ROUTER[Router / AI 专家判断<br/>输出 ExpertOpinion]
    end
    
    subgraph 判官[Module D 判官：按 TimeHorizon 分流]
        H{horizon?}
    end
    
    subgraph A轨[A 轨 现金奶牛 约80%]
        A1[2% 硬止损 · 现金拖累]
        A2[不可能三角 KPI<br/>胜率/年化/回撤]
        A3[凯利仓位 · 风控检查]
        A4[下单执行]
    end
    
    subgraph B轨[B 轨 长期捕手 约20%]
        B1[豁免 2% 与现金拖累]
        B2[逻辑证伪止损<br/>大周期反转止盈]
        B3[基本面驱动 · 锁仓]
        B4[下单执行]
    end
    
    DATA --> SCAN --> ROUTER
    ROUTER --> H
    H -->|SHORT_TERM 或未设置| A1
    H -->|LONG_TERM| B1
    A1 --> A2 --> A3 --> A4
    B1 --> B2 --> B3 --> B4
    
    style 判官 fill:#fff9c4
    style A轨 fill:#e3f2fd
    style B轨 fill:#e8f5e9
```

**通俗解释**：所有信号先经数据采集、量化扫描和 AI 专家（Router）判断；专家输出里带有一个「时间视野」标识（`TimeHorizon`）。**判官（Module D）**根据这个标识分流：短期视野走 A 轨（严止损、现金拖累、不可能三角），长期视野走 B 轨（不砍 2%、不监控空仓，只做逻辑证伪和大周期反转）。这样既能拿住时代牛股（B 轨），又不影响短线现金奶牛（A 轨）的纪律。

---

## 一、整体业务流程：从市场数据到交易执行

### 1.1 完整业务流程图（A 轨主流程）

下图为主流程，对应**现金奶牛轨（A 轨）**：2% 硬止损、现金拖累、不可能三角均适用。**B 轨**在判官处根据 `TimeHorizon = LONG_TERM` 分流，不经过下方「第五步」中的 2% 与盈亏比硬约束，见 [03_双轨制与VC-Agent](../../01_顶层概念/03_双轨制与VC-Agent.md)。

```mermaid
flowchart LR
    subgraph 第一步[第一步：数据采集]
        A[市场行情数据<br/>股票价格、成交量等]
    end
    
    subgraph 第二步[第二步：量化扫描]
        B[VectorBT 全市场扫描<br/>找出 Top 50 候选股票]
        C[三大策略池<br/>Trend/Reversion/Breakout]
    end
    
    subgraph 第三步[第三步：AI 专家判断]
        D[DeepSeek-R1 思考<br/>这个信号靠谱吗？]
        E[查询知识库<br/>Agri-KG/Tech-KG/Macro-KG]
        F[生成推理报告<br/>reasoning_summary]
    end
    
    subgraph 第四步[第四步：计算仓位]
        G[动态凯利公式<br/>应该买多少？]
        H[现金拖累监控<br/>空仓太久了吗？]
    end
    
    subgraph 第五步[第五步：风控检查（A 轨）]
        I[单笔风险 < 2%？<br/>盈亏比 > 1.5？]
    end
    
    subgraph 第六步[第六步：下单执行]
        J[通过 MiniQMT/PTrade<br/>买入/卖出]
    end
    
    A --> B
    B --> C
    C --> D
    D --> E
    E --> F
    F --> G
    G --> H
    H --> I
    I -->|通过| J
    I -->|拒绝| K[记录原因，不下单]
    
    style 第一步 fill:#e1f5ff
    style 第二步 fill:#fff4e1
    style 第三步 fill:#e8f5e9
    style 第四步 fill:#f3e5f5
    style 第五步 fill:#ffebee
    style 第六步 fill:#e0f2f1
```

**通俗解释**：
1. **数据采集**（[11_ 规约](../../03_原子目标与规约/_共享规约/11_数据采集与输入层规约.md)、[L4 实践](../../04_阶段规划与实践/Stage2_数据采集与存储/README.md)）：就像看股票行情软件，收集所有股票的价格、成交量等信息
2. **量化扫描**：用数学公式（技术指标）快速扫描全市场，找出 50 个最有潜力的股票
3. **AI 专家判断**：让 AI（DeepSeek-R1）像专业分析师一样思考：这个信号是真的机会还是假突破？AI 会查知识库（农业周期、产业链、宏观政策），然后给出推理报告
4. **计算仓位**：用凯利公式算应该买多少（不能全仓，也不能太少），同时检查是不是空仓太久了（空仓太久会降低复利速度）
5. **风控检查**：最后一道防线，检查单笔风险是否太大、盈亏比是否合理
6. **下单执行**：全部通过后，通过券商接口下单

---

## 二、核心公式的执行流程

### 2.1 核心公式：Alpha = (量化信号 ∩ AI判断) × 仓位

```mermaid
flowchart TB
    subgraph 左脑[左脑：量化扫描]
        L1[全市场扫描<br/>VectorBT]
        L2[三大策略池<br/>Trend/Reversion/Breakout]
        L3[输出 Top 50 候选<br/>technical_score: 0-100]
    end
    
    subgraph 交集[交集：AI 专家路由]
        R1[Router 选择专家<br/>根据市场状态]
        R2[DeepSeek-R1 思考<br/>CoT（思维链）推理]
        R3[查询知识库<br/>Agri-KG/Tech-KG/Macro-KG]
        R4[生成推理报告<br/>reasoning_summary]
        R5{一票否决？}
    end
    
    subgraph 右脑[右脑：AI 判断]
        Y1[通过：补全信号<br/>fundamental_score]
        Y2[否决：记录原因<br/>不进入下游]
    end
    
    subgraph 仓位[仓位管理：凯利公式]
        K1[计算 kelly_fraction<br/>0.0-1.0]
        K2[现金拖累监控<br/>空仓 > 5 天？]
    end
    
    subgraph 结果[最终结果]
        A1[Alpha 信号<br/>可以交易]
    end
    
    L1 --> L2 --> L3
    L3 --> R1
    R1 --> R2
    R2 --> R3
    R3 --> R4
    R4 --> R5
    R5 -->|通过| Y1
    R5 -->|否决| Y2
    Y1 --> K1
    K1 --> K2
    K2 --> A1
    
    style 左脑 fill:#e3f2fd
    style 交集 fill:#fff9c4
    style 右脑 fill:#e8f5e9
    style 仓位 fill:#f3e5f5
    style 结果 fill:#ffebee
```

**通俗解释**：
- **左脑（量化）**：用数学公式快速找出 50 个候选股票，给每个打分（0-100分）
- **交集（AI路由）**：AI 像专家一样判断，这个信号是真的还是假的？查知识库，给出推理报告
- **右脑（AI判断）**：如果 AI 觉得不靠谱（假突破、高风险），直接否决；如果通过，补全 AI 逻辑得分
- **仓位管理**：用凯利公式算应该买多少，同时检查是不是空仓太久了
- **最终结果**：全部通过后，生成 Alpha 信号，可以交易

---

## 三、数据如何在三层存储中流转

### 3.1 数据三层架构：热数据 → 知识库 → 冷归档

```mermaid
flowchart TB
    subgraph L1热数据[L1 热数据层：快速访问]
        TDB[(TimescaleDB<br/>实时行情/指标<br/>ESSD PL1 高性能)]
        REDIS[(Redis Cluster<br/>信号总线/去重<br/>事件流)]
    end
    
    subgraph L2知识库[L2 领域知识库：AI 推理用]
        AGRI[Agri-KG<br/>农业周期、猪周期<br/>一号文件库]
        TECH[Tech-KG<br/>产业链图谱<br/>国产替代率]
        MACRO[Macro-KG<br/>利率汇率<br/>地缘政治事件]
    end
    
    subgraph L3冷归档[L3 冷数据层：历史归档]
        OSS1[OSS 标准存储<br/>WAL 日志<br/>决策快照]
        OSS2[OSS 冷归档<br/>历史回测数据<br/>价格是标准存储的 1/10]
    end
    
    subgraph 写入[数据写入]
        W1[实时行情 → TimescaleDB]
        W2[信号 → Redis Streams]
        W3[新闻/事件 → 知识库]
        W4[日志/快照 → OSS]
    end
    
    subgraph 读取[数据读取]
        R1[量化扫描读取 TimescaleDB]
        R2[AI 推理读取知识库]
        R3[离线分析读取 OSS]
    end
    
    W1 --> TDB
    W2 --> REDIS
    W3 --> AGRI
    W3 --> TECH
    W3 --> MACRO
    W4 --> OSS1
    W4 --> OSS2
    
    TDB --> R1
    AGRI --> R2
    TECH --> R2
    MACRO --> R2
    OSS2 --> R3
    
    style L1热数据 fill:#ffebee
    style L2知识库 fill:#e8f5e9
    style L3冷归档 fill:#e3f2fd
```

**通俗解释**：
- **L1 热数据**：就像电脑的内存，快速读写。TimescaleDB 存实时行情，Redis 存信号队列
- **L2 知识库**：就像 AI 的大脑知识库，存农业周期、产业链、宏观政策等信息，AI 推理时查这些
- **L3 冷归档**：就像仓库，存历史数据。OSS（对象存储服务）标准存储存重要 WAL（预写日志）日志，冷归档存历史回测数据（便宜）

---

## 四、研产同构：回测与实盘用同一套代码

### 4.1 为什么需要研产同构？

```mermaid
flowchart LR
    subgraph 错误做法[❌ 错误做法：两套代码]
        E1[Jupyter 回测<br/>写一套逻辑]
        E2[手动翻译<br/>改成实盘代码]
        E3[实盘执行<br/>另一套逻辑]
        E4[结果不一致<br/>回测 30%，实盘 -10%]
    end
    
    subgraph 正确做法[✅ 正确做法：共享内核]
        C1[diting-core 包<br/>统一的 Strategy 类]
        C2[Backtrader 回测<br/>调用 diting-core]
        C3[实盘执行<br/>调用 diting-core]
        C4[逻辑一致<br/>回测 30%，实盘也能接近 30%]
    end
    
    E1 --> E2 --> E3 --> E4
    C1 --> C2
    C1 --> C3
    C2 --> C4
    C3 --> C4
    
    style 错误做法 fill:#ffebee
    style 正确做法 fill:#e8f5e9
```

**通俗解释**：
- **错误做法**：在 Jupyter 里写回测代码，然后手动翻译成实盘代码。结果两套逻辑不一样，回测赚 30%，实盘亏 10%
- **正确做法**：写一个 `diting-core` Python 包，回测和实盘都调用同一个 Strategy 类。这样逻辑一致，回测的结果才能延续到实盘

### 4.2 仿真沙箱：模拟盘验证

```mermaid
flowchart TB
    subgraph 阶段1[阶段1：回测验证]
        S1[Backtrader 回测<br/>历史数据验证]
        S2[验证策略逻辑<br/>胜率、复利、回撤]
    end
    
    subgraph 阶段2[阶段2：模拟盘验证]
        S3[Redis Streams<br/>回放历史 Tick 数据]
        S4[模拟真实市场<br/>事件驱动逻辑]
        S5[运行 2 周<br/>验证健壮性]
    end
    
    subgraph 阶段3[阶段3：实盘上线]
        S6[实盘执行<br/>真实交易]
    end
    
    S1 --> S2
    S2 --> S3
    S3 --> S4
    S4 --> S5
    S5 --> S6
    
    style 阶段1 fill:#e3f2fd
    style 阶段2 fill:#fff9c4
    style 阶段3 fill:#e8f5e9
```

**通俗解释**：
1. **回测**：用历史数据验证策略，看胜率、复利、回撤是否达标
2. **模拟盘**：用 Redis 回放历史数据，模拟真实市场，运行 2 周验证系统是否健壮
3. **实盘**：全部验证通过后，才上线实盘交易

---

## 五、安全治理：密钥管理流程

### 5.1 密钥如何安全存储和使用？

```mermaid
flowchart TB
    subgraph 存储[密钥存储：阿里云 KMS]
        KMS[阿里云 KMS<br/>加密存储<br/>券商密码、API Key]
    end
    
    subgraph 注入[密钥注入：ESO 动态拉取]
        ESO[External Secrets Operator<br/>从 KMS 拉取密钥]
        SECRET[K3s Secret<br/>注入 Pod 内存]
    end
    
    subgraph 使用[应用使用]
        APP[应用 Pod<br/>读取环境变量]
        TRADE[交易模块<br/>使用密钥下单]
    end
    
    subgraph 防护[安全防护]
        NP[Network Policies<br/>只有执行模块能访问券商]
        SONAR[SonarQube<br/>CI 扫描，防止密钥泄露]
    end
    
    KMS --> ESO
    ESO --> SECRET
    SECRET --> APP
    APP --> TRADE
    
    NP -.-> TRADE
    SONAR -.-> APP
    
    style 存储 fill:#ffebee
    style 注入 fill:#fff9c4
    style 使用 fill:#e8f5e9
    style 防护 fill:#e3f2fd
```

**通俗解释**：
- **存储**：所有密钥（券商密码、API Key）存在阿里云 KMS（密钥管理服务），加密存储
- **注入**：ESO（外部密钥操作符）从 KMS 拉取密钥，注入到 Pod 的内存中（不存文件）
- **使用**：应用读取环境变量使用密钥
- **防护**：Network Policies 确保只有执行模块能访问券商；SonarQube 扫描代码，防止密钥泄露

---

## 六、成本治理：如何控制成本？

### 6.1 Token（词元）预算熔断：什么时候用 AI，什么时候不用？

```mermaid
flowchart TB
    subgraph 信号评估[信号评估]
        S1[量化信号<br/>technical_score]
        S2{technical_score<br/>>= 80?}
        S3{technical_score<br/>>= 60?}
    end
    
    subgraph 推理模式[AI 推理模式]
        DEEP[Deep Think Mode<br/>完整 CoT 推理<br/>Token 消耗大]
        SIMPLE[Simple Mode<br/>快速推理<br/>Token 消耗小]
        SKIP[跳过推理<br/>直接否决<br/>Token 消耗 = 0]
    end
    
    subgraph 成本监控[成本监控]
        MONITOR[LangFuse 记录<br/>Token 消耗]
        ROI{ROI > 阈值?}
        FUSE[熔断机制<br/>停止推理]
    end
    
    S1 --> S2
    S2 -->|是| DEEP
    S2 -->|否| S3
    S3 -->|是| SIMPLE
    S3 -->|否| SKIP
    
    DEEP --> MONITOR
    SIMPLE --> MONITOR
    SKIP --> MONITOR
    
    MONITOR --> ROI
    ROI -->|否| FUSE
    
    style 信号评估 fill:#e3f2fd
    style 推理模式 fill:#fff9c4
    style 成本监控 fill:#ffebee
```

**通俗解释**：
- **高分信号（≥80分）**：用 Deep Think Mode，完整推理，Token 消耗大但值得
- **中等信号（60-80分）**：用 Simple Mode，快速推理，Token 消耗小
- **低分信号（<60分）**：跳过推理，直接否决，不浪费 Token
- **成本监控**：如果 ROI（投资回报率）太低（赚的钱不够付 Token 费），触发熔断，停止推理

### 6.2 Scale-to-Zero：任务结束就缩容

```mermaid
flowchart LR
    subgraph 任务开始[任务开始]
        T1[新任务到达]
        T2[K3s 自动扩容<br/>0 → N 个 Pod]
    end
    
    subgraph 任务执行[任务执行]
        T3[Pod 处理任务<br/>全市场扫描 + 推理]
    end
    
    subgraph 任务结束[任务结束]
        T4[任务完成]
        T5[K3s 自动缩容<br/>N → 0 个 Pod]
        T6[不付费<br/>零库存策略]
    end
    
    T1 --> T2
    T2 --> T3
    T3 --> T4
    T4 --> T5
    T5 --> T6
    
    style 任务开始 fill:#e8f5e9
    style 任务执行 fill:#fff9c4
    style 任务结束 fill:#e3f2fd
```

**通俗解释**：
- **任务开始**：有新任务时，K3s 自动扩容（从 0 个 Pod 扩容到 N 个）
- **任务执行**：Pod 处理任务（全市场扫描、AI 推理）
- **任务结束**：任务完成后，K3s 自动缩容到 0，不付费（零库存策略）

---

## 七、经纪商解耦：如何避免单点故障？

### 7.1 TAL（交易接口抽象层）抽象层：核心代码不依赖具体券商

```mermaid
flowchart TB
    subgraph 核心代码[核心策略代码]
        CORE[diting-core<br/>Strategy 类<br/>buy/sell 调用]
    end
    
    subgraph 抽象层[TAL 抽象层]
        TAL[BrokerDriver 接口<br/>buy/sell/get_position]
    end
    
    subgraph 适配器[券商适配器]
        MQMT[MiniQMT_Driver<br/>封装 MiniQMT 接口]
        PT[PTrade_Driver<br/>封装 PTrade 接口]
        OTHER[其他券商 Driver<br/>未来扩展]
    end
    
    subgraph 券商[券商接口]
        B1[MiniQMT<br/>券商A]
        B2[PTrade<br/>券商B]
    end
    
    CORE --> TAL
    TAL --> MQMT
    TAL --> PT
    TAL --> OTHER
    
    MQMT --> B1
    PT --> B2
    
    style 核心代码 fill:#e8f5e9
    style 抽象层 fill:#fff9c4
    style 适配器 fill:#e3f2fd
    style 券商 fill:#ffebee
```

**通俗解释**：
- **核心代码**：策略代码只调用 `buy()`、`sell()` 等标准接口，不关心具体券商
- **抽象层**：定义标准接口（BrokerDriver）
- **适配器**：每个券商写一个适配器（MiniQMT_Driver、PTrade_Driver），封装券商的具体接口
- **好处**：如果券商A挂了，只需切换到券商B的适配器，核心代码一行不用改

---

## 八、各战略维度如何协作？

### 8.1 维度协作关系图

```mermaid
flowchart TB
    subgraph 基础层[基础层：必须最先实现]
        D1[02_技术栈与架构<br/>Python/DeepSeek/K3s]
        D2[03_数据架构<br/>L1/L2/L3 三层]
        D4[05_安全治理<br/>KMS/ESO/Network Policies]
    end
    
    subgraph 保障层[保障层：确保稳定运行]
        D3[04_生产保障<br/>Great Expectations/Loki/Prometheus]
        D5[06_研产同构<br/>共享内核/仿真沙箱]
    end
    
    subgraph 优化层[优化层：提升效率]
        D6[07_成本治理<br/>Token 预算/Scale-to-Zero]
        D7[08_经纪商解耦<br/>TAL/多账户]
    end
    
    D1 --> D2
    D1 --> D3
    D1 --> D4
    D2 --> D3
    D4 --> D7
    D5 --> D6
    
    style 基础层 fill:#ffebee
    style 保障层 fill:#fff9c4
    style 优化层 fill:#e8f5e9
```

**通俗解释**：
- **基础层**：技术栈、数据架构、安全治理是基础，必须先实现
- **保障层**：生产保障（监控、日志）和研产同构（确保逻辑一致）确保系统稳定运行
- **优化层**：成本治理和经纪商解耦是优化，提升效率和可靠性

---

## 九、不可能三角如何通过各维度实现？（仅 A 轨）

### 9.1 不可能三角的实现路径（仅 A 轨）

```mermaid
flowchart TB
    subgraph 三角[不可能三角]
        T1[认知边界<br/>胜率 ≥ 85%]
        T2[复利增长<br/>年化 ≥ 45%]
        T3[生存底线<br/>回撤 < 12%]
    end
    
    subgraph 实现1[认知边界实现]
        I1[DeepSeek-R1 CoT<br/>可解释推理]
        I2[L2 知识库<br/>领域逻辑支撑]
        I3[研产同构<br/>回测胜率延续到实盘]
    end
    
    subgraph 实现2[复利增长实现]
        I4[VectorBT 向量化<br/>多策略池并发]
        I5[现金拖累监控<br/>空仓 > 5 天放宽阈值]
        I6[成本治理<br/>Token 预算熔断]
    end
    
    subgraph 实现3[生存底线实现]
        I7[安全治理<br/>密钥零泄露]
        I8[数据防火墙<br/>Great Expectations]
        I9[风控规则<br/>单笔风险 < 2%]
        I10[经纪商解耦<br/>避免单点故障]
    end
    
    T1 --> I1
    T1 --> I2
    T1 --> I3
    
    T2 --> I4
    T2 --> I5
    T2 --> I6
    
    T3 --> I7
    T3 --> I8
    T3 --> I9
    T3 --> I10
    
    style 三角 fill:#ffebee
    style 实现1 fill:#e8f5e9
    style 实现2 fill:#fff9c4
    style 实现3 fill:#e3f2fd
```

**通俗解释**：
- **认知边界（胜率 ≥ 85%）**：通过 DeepSeek-R1 的可解释推理、知识库的领域逻辑支撑、研产同构确保回测胜率延续到实盘
- **复利增长（年化 ≥ 45%）**：通过 VectorBT 向量化扫描多策略池并发、现金拖累监控提高资金利用率、成本治理确保 ROI 为正
- **生存底线（回撤 < 12%）**：通过安全治理防止密钥泄露、数据防火墙拦截异常数据、风控规则硬编码、经纪商解耦避免单点故障

---

## 总结

产品设计轴线（含 01 总纲与 02～09）与开发与交付轴线共同支撑不可能三角的实现：

1. **技术栈与架构**：提供基础能力（量化扫描、AI 推理、容器编排）
2. **数据架构**：提供数据支撑（热数据、知识库、冷归档）
3. **生产保障**：确保系统稳定（数据质量、可观测性、LLMOps）
4. **安全治理**：防止资产归零（密钥管理、网络隔离、代码审计）
5. **研产同构**：确保逻辑一致（回测与实盘用同一套代码）
6. **成本治理**：确保商业可行（Token 预算、Scale-to-Zero、存储优化）
7. **经纪商解耦**：避免单点故障（TAL 抽象层、多账户准备）

所有维度最终都服务于一个目标：**在胜率 ≥ 85%、年化复利 ≥ 45%、回撤 < 12% 的约束下，稳定运行并持续盈利**。
